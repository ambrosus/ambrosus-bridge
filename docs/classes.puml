@startuml



class Bsc_AmbBridge {
    +SubmitTransferClique(CliqueProof proof)
}
class Bsc_BscBridge {
    +SubmitTransferAura(AuraProof proof)
}

class Eth_AmbBridge {
    +SubmitTransferPoW(PoWProof proof)
}
class Eth_EthBridge {
    +SubmitTransferAura(AuraProof proof)
}


abstract class CheckPoW {
    -CheckPoW(PoWProof proof)
}

abstract class CheckAura {
    -CheckAura(AuraProof proof)
}

abstract class CheckClique {
    -CheckClique(CliqueProof proof)
}


entity BlockPoW {
    +bytes p1;
    +bytes32 prevHashOrReceiptRoot;
    +bytes p2;
    +bytes difficulty;
    +bytes p3;
}

entity BlockClique {
    +bytes p1;
    +bytes32 prevHashOrReceiptRoot;
    +bytes p2;
    +bytes difficulty;
    +bytes p3;
}

entity BlockAura {
    +bytes p0_seal;
    +bytes p0_bare;

    +bytes p1;
    +bytes32 prevHashOrReceiptRoot;
    +bytes p2;
    +bytes timestamp;
    +bytes p3;

    +bytes s1;
    +bytes signature;
    +bytes s2;
}



abstract class CommonBridge {
    +mapping(address=>address) tokenAddresses
    +address sideBridgeAddress
    +uint fee
    +uint lockTime
    +uint timeframe

    -uint lastTimeframe
    +uint inputEventId
    -uint outputEventId
    -Transfer[] withdraw_queue
    --
    +withdraw(tokenAddress, toAddress, amount, unwrap)
    +wrapWithdraw(toAddress)
    --admin--
    +tokenAddresses update methods ()
    +setFee()
    +setTimeframe()
    +setLockTime()
    +pause() / unpause()
}


entity Transfer {
    +tokenAddress
    +toAddress
    +amount
}


Eth_AmbBridge --> CheckPoW
Eth_EthBridge --> CheckAura

Bsc_BscBridge --> CheckAura
Bsc_AmbBridge --> CheckClique

CheckPoW --> BlockPoW
CheckClique --> BlockClique
CheckAura --> BlockAura

CheckPoW --> Transfer
CheckClique --> Transfer
CheckAura --> Transfer

Eth_AmbBridge --> CommonBridge
Eth_EthBridge --> CommonBridge
Bsc_AmbBridge --> CommonBridge
Bsc_BscBridge --> CommonBridge

CommonBridge --> Transfer


@enduml
